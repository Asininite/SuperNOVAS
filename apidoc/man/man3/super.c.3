.TH "src/super.c" 3 "Version v1.3" "SuperNOVAS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/super.c
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB_DEFAULT_SOURCE\fP"
.br
.RI "strcasecmp() feature macro starting glibc 2\&.20 (2014-09-08) "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBapp_to_cirs_ra\fP (double jd_tt, enum \fBnovas_accuracy\fP accuracy, double ra)"
.br
.ti -1c
.RI "double \fBcirs_to_app_ra\fP (double jd_tt, enum \fBnovas_accuracy\fP accuracy, double ra)"
.br
.ti -1c
.RI "int \fBcirs_to_itrs\fP (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double *in, double *out)"
.br
.ti -1c
.RI "int \fBcirs_to_tod\fP (double jd_tt, enum \fBnovas_accuracy\fP accuracy, const double *in, double *out)"
.br
.ti -1c
.RI "int \fBecl2equ\fP (double jd_tt, enum \fBnovas_equator_type\fP coord_sys, enum \fBnovas_accuracy\fP accuracy, double elon, double elat, double *ra, double *dec)"
.br
.ti -1c
.RI "int \fBgal2equ\fP (double glon, double glat, double *ra, double *dec)"
.br
.ti -1c
.RI "double \fBget_ut1_to_tt\fP (int leap_seconds, double dut1)"
.br
.ti -1c
.RI "double \fBget_utc_to_tt\fP (int leap_seconds)"
.br
.ti -1c
.RI "double \fBgrav_redshift\fP (double M_kg, double r_m)"
.br
.ti -1c
.RI "int \fBgrav_undef\fP (double jd_tdb, enum \fBnovas_accuracy\fP accuracy, const double *pos_app, const double *pos_obs, double *out)"
.br
.ti -1c
.RI "int \fBgrav_undo_planets\fP (const double *pos_app, const double *pos_obs, const \fBnovas_planet_bundle\fP *planets, double *out)"
.br
.ti -1c
.RI "int \fBhor_to_itrs\fP (const \fBon_surface\fP *location, double az, double za, double *itrs)"
.br
.ti -1c
.RI "int \fBitrs_to_cirs\fP (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double *in, double *out)"
.br
.ti -1c
.RI "int \fBitrs_to_hor\fP (const \fBon_surface\fP *location, const double *itrs, double *az, double *za)"
.br
.ti -1c
.RI "int \fBitrs_to_tod\fP (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double *in, double *out)"
.br
.ti -1c
.RI "int \fBj2000_to_gcrs\fP (const double *in, double *out)"
.br
.ti -1c
.RI "int \fBmake_airborne_observer\fP (const \fBon_surface\fP *location, const double *vel, \fBobserver\fP *obs)"
.br
.ti -1c
.RI "int \fBmake_cat_object\fP (const \fBcat_entry\fP *star, \fBobject\fP *source)"
.br
.ti -1c
.RI "int \fBmake_ephem_object\fP (const char *name, long num, \fBobject\fP *body)"
.br
.ti -1c
.RI "int \fBmake_orbital_object\fP (const char *name, long num, const \fBnovas_orbital\fP *orbit, \fBobject\fP *body)"
.br
.ti -1c
.RI "int \fBmake_redshifted_cat_entry\fP (const char *name, double ra, double dec, double z, \fBcat_entry\fP *source)"
.br
.ti -1c
.RI "int \fBmake_redshifted_object\fP (const char *name, double ra, double dec, double z, \fBobject\fP *source)"
.br
.ti -1c
.RI "int \fBmake_solar_system_observer\fP (const double *sc_pos, const double *sc_vel, \fBobserver\fP *obs)"
.br
.ti -1c
.RI "double \fBnovas_dms_degrees\fP (const char *dms)"
.br
.ti -1c
.RI "int \fBnovas_e2h_offset\fP (double dra, double ddec, double pa, double *daz, double *del)"
.br
.ti -1c
.RI "double \fBnovas_epa\fP (double ha, double dec, double lat)"
.br
.ti -1c
.RI "double \fBnovas_equ_sep\fP (double ra1, double dec1, double ra2, double dec2)"
.br
.ti -1c
.RI "int \fBnovas_h2e_offset\fP (double daz, double del, double pa, double *dra, double *ddec)"
.br
.ti -1c
.RI "double \fBnovas_helio_dist\fP (double jd_tdb, const \fBobject\fP *source, double *rate)"
.br
.ti -1c
.RI "double \fBnovas_hms_hours\fP (const char *hms)"
.br
.ti -1c
.RI "double \fBnovas_hpa\fP (double az, double el, double lat)"
.br
.ti -1c
.RI "double \fBnovas_lsr_to_ssb_vel\fP (double epoch, double ra, double dec, double vLSR)"
.br
.ti -1c
.RI "double \fBnovas_parse_dms\fP (const char *dms, char **tail)"
.br
.ti -1c
.RI "double \fBnovas_parse_hms\fP (const char *hms, char **tail)"
.br
.ti -1c
.RI "enum \fBnovas_planet\fP \fBnovas_planet_for_name\fP (const char *name)"
.br
.ti -1c
.RI "double \fBnovas_sep\fP (double lon1, double lat1, double lon2, double lat2)"
.br
.ti -1c
.RI "int \fBnovas_set_orbsys_pole\fP (enum \fBnovas_reference_system\fP type, double ra, double dec, \fBnovas_orbital_system\fP *sys)"
.br
.ti -1c
.RI "double \fBnovas_solar_power\fP (double jd_tdb, const \fBobject\fP *source)"
.br
.ti -1c
.RI "double \fBnovas_ssb_to_lsr_vel\fP (double epoch, double ra, double dec, double vLSR)"
.br
.ti -1c
.RI "double \fBnovas_v2z\fP (double vel)"
.br
.ti -1c
.RI "int \fBnovas_xyz_to_uvw\fP (const double *xyz, double ha, double dec, double *uvw)"
.br
.ti -1c
.RI "double \fBnovas_z_add\fP (double z1, double z2)"
.br
.ti -1c
.RI "double \fBnovas_z_inv\fP (double z)"
.br
.ti -1c
.RI "int \fBplace_cirs\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "int \fBplace_gcrs\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "int \fBplace_icrs\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "int \fBplace_j2000\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "int \fBplace_mod\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "int \fBplace_tod\fP (double jd_tt, const \fBobject\fP *source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP *pos)"
.br
.ti -1c
.RI "double \fBredshift_vrad\fP (double vrad, double z)"
.br
.ti -1c
.RI "int \fBtod_to_cirs\fP (double jd_tt, enum \fBnovas_accuracy\fP accuracy, const double *in, double *out)"
.br
.ti -1c
.RI "int \fBtod_to_itrs\fP (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double *in, double *out)"
.br
.ti -1c
.RI "double \fBunredshift_vrad\fP (double vrad, double z)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBDate\fP
.RS 4
Created on Aug 24, 2024 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
SuperNOVAS only functions, which are not integral to the functionality of \fBnovas\&.c\fP, and thus can live in a separate, more manageably sized, module\&. 
.SH "Function Documentation"
.PP 
.SS "double app_to_cirs_ra (double jd_tt, enum \fBnovas_accuracy\fP accuracy, double ra)"
Converts an apparent right ascension coordinate (measured from the true equinox of date) to a CIRS R\&.A\&., measured from the CIO\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIra\fP [h] the apparent R\&.A\&. coordinate measured from the true equinox of date\&. 
.RE
.PP
\fBReturns\fP
.RS 4
[h] The CIRS right ascension coordinate, measured from the CIO [0:24], or NAN if the accuracy is invalid, or if there wan an error from \fBcio_ra()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBcirs_to_app_ra()\fP 
.PP
\fBtod_to_cirs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcio_ra()\fP\&.
.SS "double cirs_to_app_ra (double jd_tt, enum \fBnovas_accuracy\fP accuracy, double ra)"
Converts a CIRS right ascension coordinate (measured from the CIO) to an apparent R\&.A\&. measured from the true equinox of date\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIra\fP [h] The CIRS right ascension coordinate, measured from the CIO\&. 
.RE
.PP
\fBReturns\fP
.RS 4
[h] the apparent R\&.A\&. coordinate measured from the true equinox of date [0:24], or NAN if the accuracy is invalid, or if there wan an error from \fBcio_ra()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBapp_to_cirs_ra()\fP 
.PP
\fBcirs_to_tod()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcio_ra()\fP\&.
.SS "int cirs_to_itrs (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double * in, double * out)"
Rotates a position vector from the dynamical CIRS frame of date to the Earth-fixed ITRS frame (IAU 2000 standard method)\&.
.PP
If both 'xp' and 'yp' are set to 0 no polar motion is included in the transformation\&.
.PP
If extreme (sub-microarcsecond) accuracy is not required, you can use UT1-based Julian date instead of the TT-based Julian date and set the 'ut1_to_tt' argument to 0\&.0\&. and you can use UTC-based Julian date the same way\&.for arcsec-level precision also\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Kaplan, G\&. H\&. et\&. al\&. (1989)\&. Astron\&. Journ\&. 97, 1197-1210\&. 
.IP "2." 4
Kaplan, G\&. H\&. (2003), 'Another Look at Non-Rotating Origins', Proceedings of IAU XXV Joint Discussion 16\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tt_high\fP [day] High-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIjd_tt_low\fP [day] Low-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIut1_to_tt\fP [s] TT - UT1 Time difference in seconds 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIxp\fP [arcsec] Conventionally-defined X coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIyp\fP [arcsec] Conventionally-defined Y coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIin\fP Position vector, geocentric equatorial rectangular coordinates, referred to CIRS axes (celestial system)\&. 
.br
\fIout\fP Position vector, geocentric equatorial rectangular coordinates, referred to ITRS axes (terrestrial system)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if either of the vector arguments is NULL, 1 if 'accuracy' is invalid, 2 if 'method' is invalid 10--20, 3 if the method and option are mutually incompatible, or else 10 + the error from \fBcio_location()\fP, or 20 + error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBtod_to_itrs()\fP 
.PP
\fBitrs_to_cirs()\fP 
.PP
\fBgcrs_to_cirs()\fP 
.PP
\fBcirs_to_gcrs()\fP 
.PP
\fBcirs_to_tod()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcel2ter()\fP, \fBEROT_ERA\fP, and \fBNOVAS_DYNAMICAL_CLASS\fP\&.
.SS "int cirs_to_tod (double jd_tt, enum \fBnovas_accuracy\fP accuracy, const double * in, double * out)"
Transforms a rectangular equatorial (x, y, z) vector from the Celestial Intermediate Reference System (CIRS) at the given epoch to the True of Date (TOD) reference system\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date that defines the output epoch\&. Typically it does not require much precision, and Julian dates in other time measures will be unlikely to affect the result 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIin\fP CIRS Input (x, y, z) position or velocity vector 
.br
\fIout\fP Output position or velocity 3-vector in the True of Date (TOD) frame\&. It can be the same vector as the input\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if either of the vector arguments is NULL or the accuracy is invalid, or 10 + the error from \fBcio_location()\fP, or else 20 + the error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBtod_to_cirs()\fP 
.PP
\fBcirs_to_app_ra()\fP 
.PP
\fBcirs_to_gcrs()\fP 
.PP
\fBcirs_to_itrs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcio_ra()\fP, and \fBspin()\fP\&.
.SS "int ecl2equ (double jd_tt, enum \fBnovas_equator_type\fP coord_sys, enum \fBnovas_accuracy\fP accuracy, double elon, double elat, double * ra, double * dec)"
Convert ecliptic longitude and latitude to right ascension and declination\&. To convert GCRS ecliptic coordinates (mean ecliptic and equinox of J2000\&.0), set 'coord_sys' to \fBNOVAS_GCRS_EQUATOR(2)\fP; in this case the value of 'jd_tt' can be set to anything, since J2000\&.0 is assumed\&. Otherwise, all input coordinates are dynamical at'jd_tt'\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date\&. (Unused if 'coord_sys' is NOVAS_GCRS_EQUATOR[2]) 
.br
\fIcoord_sys\fP The astrometric reference system of the coordinates\&. If 'coord_sys' is \fBNOVAS_GCRS_EQUATOR(2)\fP, the input GCRS coordinates are converted to J2000 ecliptic coordinates\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIelon\fP [deg] Ecliptic longitude in degrees, referred to specified ecliptic and equinox of date\&. 
.br
\fIelat\fP [deg] Ecliptic latitude in degrees, referred to specified ecliptic and equinox of date\&. 
.br
\fIra\fP [h] Right ascension in hours, referred to specified equator and equinox of date\&. 
.br
\fIdec\fP [deg] Declination in degrees, referred to specified equator and equinox of date\&.
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else 1 if the value of 'coord_sys' is invalid\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBecl2equ_vec()\fP 
.PP
\fBequ2ecl()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBecl2equ_vec()\fP\&.
.SS "int gal2equ (double glon, double glat, double * ra, double * dec)"
Converts galactic longitude and latitude to ICRS right ascension and declination\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Hipparcos and Tycho Catalogues, Vol\&. 1, Section 1\&.5\&.3\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIglon\fP [deg] Galactic longitude in degrees\&. 
.br
\fIglat\fP [deg] Galactic latitude in degrees\&. 
.br
\fIra\fP [h] ICRS right ascension in hours\&. 
.br
\fIdec\fP [deg] ICRS declination in degrees\&.
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if either of the output pointer arguments are NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBequ2gal()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.SS "double get_ut1_to_tt (int leap_seconds, double dut1)"
Returns the TT - UT1 time difference given the leap seconds and the actual UT1 - UTC time difference as measured and published by IERS\&.
.PP
NOTES: 
.PD 0
.IP "1." 4
The current UT1 - UTC time difference, and polar offsets, historical data and near-term projections are published in the <a href="https://www.iers.org/IERS/EN/Publications/Bulletins/bulletins.html>IERS Bulletins  
.PP
.PP
\fBParameters\fP
.RS 4
\fIleap_seconds\fP [s] Leap seconds at the time of observations 
.br
\fIdut1\fP [s] UT1 - UTC time difference [-0\&.5:0\&.5] 
.RE
.PP
\fBReturns\fP
.RS 4
[s] The TT - UT1 time difference that is suitable for used with all calls in this library that require a \fCut1_to_tt\fP argument\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBget_utc_to_tt()\fP 
.PP
\fBplace()\fP 
.PP
\fBcel_pole()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBget_utc_to_tt()\fP\&.
.SS "double get_utc_to_tt (int leap_seconds)"
Returns the difference between Terrestrial Time (TT) and Universal Coordinated Time (UTC)
.PP
\fBParameters\fP
.RS 4
\fIleap_seconds\fP [s] The current leap seconds (see IERS Bulletins) 
.RE
.PP
\fBReturns\fP
.RS 4
[s] The TT - UTC time difference
.RE
.PP
\fBSee also\fP
.RS 4
\fBget_ut1_to_tt()\fP 
.PP
\fBjulian_date()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_TAI_TO_TT\fP\&.
.SS "double grav_redshift (double M_kg, double r_m)"
Returns the gravitational redshift (\fIz\fP) for light emitted near a massive spherical body at some distance from its center, and observed at some very large (infinite) distance away\&.
.PP
\fBParameters\fP
.RS 4
\fIM_kg\fP [kg] Mass of gravitating body that is contained inside the emitting radius\&. 
.br
\fIr_m\fP [m] Radius at which light is emitted\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The gravitational redshift (\fIz\fP) for an observer at very large (infinite) distance from the gravitating body\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredshift_vrad()\fP 
.PP
\fBunredshift_vrad()\fP 
.PP
\fBnovas_z_add()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBC\fP\&.
.SS "int grav_undef (double jd_tdb, enum \fBnovas_accuracy\fP accuracy, const double * pos_app, const double * pos_obs, double * out)"
Computes the gravitationally undeflected position of an observed source position due to the major gravitating bodies in the solar system\&. This function valid for an observed body within the solar system as well as for a star\&.
.PP
If 'accuracy' is set to zero (full accuracy), three bodies (Sun, Jupiter, and Saturn) are used in the calculation\&. If the reduced-accuracy option is set, only the Sun is used in the calculation\&. In both cases, if the observer is not at the geocenter, the deflection due to the Earth is included\&.
.PP
The number of bodies used at full and reduced accuracy can be set by making a change to the code in this function as indicated in the comments\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Klioner, S\&. (2003), Astronomical Journal 125, 1580-1597, Section 6\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tdb\fP [day] Barycentric Dynamical Time (TDB) based Julian date 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos_app\fP [AU] Apparent position 3-vector of observed object, with respect to origin at observer (or the geocenter), referred to ICRS axes, components in AU\&. 
.br
\fIpos_obs\fP [AU] Position 3-vector of observer (or the geocenter), with respect to origin at solar system barycenter, referred to ICRS axes, components in AU\&. 
.br
\fIout\fP [AU] Nominal position vector of observed object, with respect to origin at observer (or the geocenter), referred to ICRS axes, without gravitational deflection, components in AU\&. It can be the same vector as the input, but not the same as pos_obs\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if any of the pointer arguments is NULL (errno = EINVAL) or if the result did not converge (errno = ECANCELED), or else an error from \fBobs_planets()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBgrav_def()\fP 
.PP
\fBnovas_app_to_geom()\fP 
.PP
\fBset_planet_provider()\fP 
.PP
\fBset_planet_provider_hp()\fP 
.PP
\fBgrav_bodies_full_accuracy\fP 
.PP
\fBgrav_bodies_reduced_accuracy\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBgrav_bodies_full_accuracy\fP, \fBgrav_bodies_reduced_accuracy\fP, \fBgrav_undo_planets()\fP, \fBNOVAS_FULL_ACCURACY\fP, and \fBobs_planets()\fP\&.
.SS "int grav_undo_planets (const double * pos_app, const double * pos_obs, const \fBnovas_planet_bundle\fP * planets, double * out)"
Computes the gravitationally undeflected position of an observed source position due to the specified Solar-system bodies\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Klioner, S\&. (2003), Astronomical Journal 125, 1580-1597, Section 6\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIpos_app\fP [AU] Apparent position 3-vector of observed object, with respect to origin at observer (or the geocenter), referred to ICRS axes, components in AU\&. 
.br
\fIpos_obs\fP [AU] Position 3-vector of observer (or the geocenter), with respect to origin at solar system barycenter, referred to ICRS axes, components in AU\&. 
.br
\fIplanets\fP Apparent planet data containing positions and velocities for the major gravitating bodies in the solar-system\&. 
.br
\fIout\fP [AU] Nominal position vector of observed object, with respect to origin at observer (or the geocenter), referred to ICRS axes, without gravitational deflection, components in AU\&. It can be the same vector as the input, but not the same as pos_obs\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if any of the pointer arguments is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBobs_planets()\fP 
.PP
\fBgrav_planets()\fP 
.PP
\fBnovas_app_to_geom()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBgrav_planets()\fP, and \fBnovas_inv_max_iter\fP\&.
.SS "int hor_to_itrs (const \fBon_surface\fP * location, double az, double za, double * itrs)"
Converts astrometric (unrefracted) azimuth and zenith angles at the specified observer location to a unit position vector in the Earth-fixed ITRS frame\&.
.PP
\fBParameters\fP
.RS 4
\fIlocation\fP Observer location on Earth 
.br
\fIaz\fP [deg] astrometric azimuth angle at observer location [0:360]\&. It may be NULL if not required\&. 
.br
\fIza\fP [deg] astrometric zenith angle at observer location [0:180]\&. It may be NULL if not required\&. 
.br
\fIitrs\fP Unit 3-vector direction in Earth-fixed ITRS frame 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else -1 if the location or the input vector is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBitrs_to_hor()\fP 
.PP
\fBitrs_to_cirs()\fP 
.PP
\fBitrs_to_tod()\fP 
.PP
\fBrefract()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBon_surface::latitude\fP, and \fBon_surface::longitude\fP\&.
.SS "int itrs_to_cirs (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double * in, double * out)"
Rotates a position vector from the Earth-fixed ITRS frame to the dynamical CIRS frame of date (IAU 2000 standard method)\&.
.PP
If both 'xp' and 'yp' are set to 0 no polar motion is included in the transformation\&.
.PP
If extreme (sub-microarcsecond) accuracy is not required, you can use UT1-based Julian date instead of the TT-based Julian date and set the 'ut1_to_tt' argument to 0\&.0\&. and you can use UTC-based Julian date the same way\&.for arcsec-level precision also\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Kaplan, G\&. H\&. et\&. al\&. (1989)\&. Astron\&. Journ\&. 97, 1197-1210\&. 
.IP "2." 4
Kaplan, G\&. H\&. (2003), 'Another Look at Non-Rotating Origins', Proceedings of IAU XXV Joint Discussion 16\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tt_high\fP [day] High-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIjd_tt_low\fP [day] Low-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIut1_to_tt\fP [s] TT - UT1 Time difference in seconds 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIxp\fP [arcsec] Conventionally-defined X coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIyp\fP [arcsec] Conventionally-defined Y coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIin\fP Position vector, geocentric equatorial rectangular coordinates, referred to ITRS axes (terrestrial system) 
.br
\fIout\fP Position vector, geocentric equatorial rectangular coordinates, referred to CIRS axes (celestial system)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if either of the vector arguments is NULL, 1 if 'accuracy' is invalid, or else 10 + the error from \fBcio_location()\fP, or 20 + error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBitrs_to_tod()\fP 
.PP
\fBcirs_to_itrs()\fP 
.PP
\fBcirs_to_gcrs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBEROT_ERA\fP, \fBNOVAS_DYNAMICAL_CLASS\fP, and \fBter2cel()\fP\&.
.SS "int itrs_to_hor (const \fBon_surface\fP * location, const double * itrs, double * az, double * za)"
Converts a position vector in the Earth-fixed ITRS frame to astrometric (unrefracted) azimuth and zenith angles at the specified observer location\&.
.PP
\fBParameters\fP
.RS 4
\fIlocation\fP Observer location on Earth 
.br
\fIitrs\fP 3-vector position in Earth-fixed ITRS frame 
.br
\fIaz\fP [deg] astrometric azimuth angle at observer location [0:360]\&. It may be NULL if not required\&. 
.br
\fIza\fP [deg] astrometric zenith angle at observer location [0:180]\&. It may be NULL if not required\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else -1 if the location or the input vector is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBhor_to_itrs()\fP 
.PP
\fBcirs_to_itrs()\fP 
.PP
\fBtod_to_itrs()\fP 
.PP
\fBrefract_astro()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBon_surface::latitude\fP, and \fBon_surface::longitude\fP\&.
.SS "int itrs_to_tod (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double * in, double * out)"
Rotates a position vector from the Earth-fixed ITRS frame to the dynamical True of Date (TOD) frame of date (pre IAU 2000 method)\&.
.PP
If both 'xp' and 'yp' are set to 0 no polar motion is included in the transformation\&.
.PP
If extreme (sub-microarcsecond) accuracy is not required, you can use UT1-based Julian date instead of the TT-based Julian date and set the 'ut1_to_tt' argument to 0\&.0\&. and you can use UTC-based Julian date the same way\&.for arcsec-level precision also\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Kaplan, G\&. H\&. et\&. al\&. (1989)\&. Astron\&. Journ\&. 97, 1197-1210\&. 
.IP "2." 4
Kaplan, G\&. H\&. (2003), 'Another Look at Non-Rotating Origins', Proceedings of IAU XXV Joint Discussion 16\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tt_high\fP [day] High-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIjd_tt_low\fP [day] Low-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIut1_to_tt\fP [s] TT - UT1 Time difference in seconds 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIxp\fP [arcsec] Conventionally-defined X coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIyp\fP [arcsec] Conventionally-defined Y coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIin\fP Position vector, geocentric equatorial rectangular coordinates, referred to ITRS axes (terrestrial system) 
.br
\fIout\fP Position vector, geocentric equatorial rectangular coordinates, referred to True of Date (TOD) axes (celestial system) 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if either of the vector arguments is NULL, 1 if 'accuracy' is invalid, or else 10 + the error from \fBcio_location()\fP, or 20 + error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBitrs_to_cirs()\fP 
.PP
\fBtod_to_itrs()\fP 
.PP
\fBtod_to_j2000()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBEROT_GST\fP, \fBNOVAS_DYNAMICAL_CLASS\fP, and \fBter2cel()\fP\&.
.SS "int j2000_to_gcrs (const double * in, double * out)"
Change J2000 coordinates to GCRS coordinates\&. Same as \fBframe_tie()\fP called with J2000_TO_ICRS
.PP
\fBParameters\fP
.RS 4
\fIin\fP J2000 input 3-vector 
.br
\fIout\fP GCRS output 3-vector 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else an error from \fBframe_tie()\fP
.RE
.PP
\fBSee also\fP
.RS 4
\fBj2000_to_tod()\fP 
.PP
\fBgcrs_to_j2000()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBframe_tie()\fP, and \fBJ2000_TO_ICRS\fP\&.
.SS "int make_airborne_observer (const \fBon_surface\fP * location, const double * vel, \fBobserver\fP * obs)"
Populates an 'observer' data structure for an observer moving relative to the surface of Earth, such as an airborne observer\&. Airborne observers have an earth fixed momentary location, defined by longitude, latitude, and altitude, the same was as for a stationary observer on Earth, but are moving relative to the surface, such as in an aircraft or balloon observatory\&.
.PP
\fBParameters\fP
.RS 4
\fIlocation\fP Current longitude, latitude and altitude, and local weather (temperature and pressure) 
.br
\fIvel\fP [km/s] Surface velocity\&. 
.br
\fIobs\fP Pointer to data structure to populate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if the output argument is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
make_observer_at geocenter() 
.PP
\fBmake_observer_in_space()\fP 
.PP
\fBmake_observer_on_surface()\fP 
.PP
\fBmake_solar_system_observer()\fP 
.PP
novas_calc_geometric_position() 
.PP
\fBplace()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBIN_SPACE_INIT\fP, \fBmake_observer()\fP, \fBNOVAS_AIRBORNE_OBSERVER\fP, and \fBin_space::sc_vel\fP\&.
.SS "int make_cat_object (const \fBcat_entry\fP * star, \fBobject\fP * source)"
Populates and object data structure with the data for a catalog source\&.
.PP
\fBParameters\fP
.RS 4
\fIstar\fP Pointer to structure to populate with the catalog data for a celestial object located outside the solar system\&. 
.br
\fIsource\fP Pointer to the celestial object data structure to be populated\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if 'cel_obj' is NULL or when type is NOVAS_CATALOG_OBJECT and 'star' is NULL, or else 1 if 'type' is invalid, 2 if 'number' is out of legal range or 5 if 'name' is too long\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_cat_entry()\fP 
.PP
\fBmake_planet()\fP 
.PP
\fBmake_ephem_object()\fP 
.PP
\fBnovas_geom_posvel()\fP 
.PP
\fBplace()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_object()\fP, \fBNOVAS_CATALOG_OBJECT\fP, \fBcat_entry::starname\fP, and \fBcat_entry::starnumber\fP\&.
.SS "int make_ephem_object (const char * name, long num, \fBobject\fP * body)"
Sets a celestial object to be a Solar-system ephemeris body\&. Typically this would be used to define minor planets, asteroids, comets and planetary satellites\&.
.PP
\fBParameters\fP
.RS 4
\fIname\fP Name of object\&. By default converted to upper-case, unless \fBnovas_case_sensitive()\fP was called with a non-zero argument\&. Max\&. SIZE_OF_OBJ_NAME long, including termination\&. If the ephemeris provider uses names, then the name should match those of the ephemeris provider -- otherwise it is not important\&. 
.br
\fInum\fP Solar-system body ID number (e\&.g\&. NAIF)\&. The number should match the needs of the ephemeris provider used with NOVAS\&. (If the ephemeris provider is by name and not ID number, then the number here is not important)\&. 
.br
\fIbody\fP Pointer to structure to populate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else -1 if the 'body' pointer is NULL or the name is too long\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBset_ephem_provider()\fP 
.PP
\fBmake_planet()\fP 
.PP
\fBmake_cat_entry()\fP 
.PP
\fBnovas_geom_posvel()\fP 
.PP
\fBplace()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_object()\fP, and \fBNOVAS_EPHEM_OBJECT\fP\&.
.SS "int make_orbital_object (const char * name, long num, const \fBnovas_orbital\fP * orbit, \fBobject\fP * body)"
Sets a celestial object to be a Solar-system orbital body\&. Typically this would be used to define minor planets, asteroids, comets, or even planetary satellites\&.
.PP
\fBParameters\fP
.RS 4
\fIname\fP Name of object\&. It may be NULL if not relevant\&. 
.br
\fInum\fP Solar-system body ID number (e\&.g\&. NAIF)\&. It is not required and can be set e\&.g\&. to -1 if not relevant to the caller\&. 
.br
\fIorbit\fP The orbital parameters to adopt\&. The data will be copied, not referenced\&. 
.br
\fIbody\fP Pointer to structure to populate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else -1 if the 'orbit' or 'body' pointer is NULL or the name is too long\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_orbit_posvel()\fP 
.PP
\fBmake_planet()\fP 
.PP
\fBmake_ephem_object()\fP 
.PP
\fBnovas_geom_posvel()\fP 
.PP
\fBplace()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_object()\fP, \fBNOVAS_ORBITAL_OBJECT\fP, and \fBobject::orbit\fP\&.
.SS "int make_redshifted_cat_entry (const char * name, double ra, double dec, double z, \fBcat_entry\fP * source)"
Populates a celestial object data structure with the parameters for a redhifted catalog source, such as a distant quasar or galaxy\&. It is similar to \fC\fBmake_cat_object()\fP\fP except that it takes a Doppler-shift (z) instead of radial velocity and it assumes no parallax and no proper motion (appropriately for a distant redshifted source)\&. The catalog name is set to \fCEXT\fP to indicate an extragalactic source, and the catalog number defaults to 0\&. The user may change these default field values as appropriate afterwards, if necessary\&.
.PP
\fBParameters\fP
.RS 4
\fIname\fP Object name (less than SIZE_OF_OBJ_NAME in length)\&. It may be NULL\&. 
.br
\fIra\fP [h] Right ascension of the object (hours)\&. 
.br
\fIdec\fP [deg] Declination of the object (degrees)\&. 
.br
\fIz\fP Redhift value (\*<obs\*>  / \*<rest\*>  - 1 = f\*<rest\*>  / f\*<obs\*>  - 1)\&. 
.br
\fIsource\fP Pointer to structure to populate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or 5 if 'name' is too long, else -1 if the 'source' pointer is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_redshifted_object()\fP 
.PP
\fBnovas_v2z()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_cat_entry()\fP, and \fBnovas_z2v()\fP\&.
.SS "int make_redshifted_object (const char * name, double ra, double dec, double z, \fBobject\fP * source)"
Populates a celestial object data structure with the parameters for a redhifted catalog source, such as a distant quasar or galaxy\&. It is similar to \fC\fBmake_cat_object()\fP\fP except that it takes a Doppler-shift (z) instead of radial velocity and it assumes no parallax and no proper motion (appropriately for a distant redshifted source)\&. The catalog name is set to \fCEXT\fP to indicate an extragalactic source, and the catalog number defaults to 0\&. The user may change these default field values as appropriate afterwards, if necessary\&.
.PP
\fBParameters\fP
.RS 4
\fIname\fP Object name (less than SIZE_OF_OBJ_NAME in length)\&. It may be NULL\&. 
.br
\fIra\fP [h] Right ascension of the object (hours)\&. 
.br
\fIdec\fP [deg] Declination of the object (degrees)\&. 
.br
\fIz\fP Redhift value (\*<obs\*>  / \*<rest\*>  - 1 = f\*<rest\*>  / f\*<obs\*>  - 1)\&. 
.br
\fIsource\fP Pointer to structure to populate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or 5 if 'name' is too long, else -1 if the 'source' pointer is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
make_redshifted_cat_object() 
.PP
\fBnovas_v2z()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_cat_object()\fP, and \fBmake_redshifted_cat_entry()\fP\&.
.SS "int make_solar_system_observer (const double * sc_pos, const double * sc_vel, \fBobserver\fP * obs)"
Populates an 'observer' data structure, for an observer situated on a near-Earth spacecraft, with the specified geocentric position and velocity vectors\&. Solar-system observers are similar to observers in Earth-orbit but their momentary position and velocity is defined relative to the Solar System Barycenter, instead of the geocenter\&.
.PP
\fBParameters\fP
.RS 4
\fIsc_pos\fP [AU] Solar-system barycentric (x, y, z) position vector in ICRS\&. 
.br
\fIsc_vel\fP [AU/day] Solar-system barycentric (x, y, z) velocity vector in ICRS\&. 
.br
\fIobs\fP Pointer to the data structure to populate 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if the output argument is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_observer_in_space()\fP 
.PP
\fBmake_observer_on_surface()\fP 
.PP
\fBmake_observer_at_geocenter()\fP 
.PP
\fBmake_airborne_observer()\fP 
.PP
novas_calc_geometric_position() 
.PP
\fBplace()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBmake_in_space()\fP, \fBmake_observer()\fP, and \fBNOVAS_SOLAR_SYSTEM_OBSERVER\fP\&.
.SS "double novas_dms_degrees (const char * dms)"
Returns the decimal degrees for a DMS string specification\&. The degree, (arc)minute, and (arc)second components may be separated by spaces, tabs, colons \fC:\fP, or a combination thereof\&. Additionally, the degree and minutes may be semarated by the letter \fCd\fP or \fCD\fP, and the minutes and seconds may be separated by \fCm\fP or \fCM\fP, or a single quote `'`\&. For example, all of the lines below specify the same angle:
.PP
.PP
.nf

 -179:59:59\&.999
 -179 59m 59\&.999
 -179d 59' 59\&.999
 -179D59'59\&.999
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIdms\fP String specifying degrees, minutes, and seconds, which correspond to an angle\&. Angles in any range are permitted, but the minutes and seconds must be >=0 and <60\&. 
.RE
.PP
\fBReturns\fP
.RS 4
[deg] Corresponding decimal angle value, or else NAN if there was an error parsing the string (errno will be set to EINVAL)\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_hms_hours()\fP 
.RE
.PP

.PP
References \fBnovas_parse_dms()\fP\&.
.SS "int novas_e2h_offset (double dra, double ddec, double pa, double * daz, double * del)"
Converts coordinate offsets, from the local equatorial system to local horizontal offsets\&. Converting between local flat projections and spherical coordinates usually requires a WCS projection\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Calabretta, M\&.R\&., & Greisen, E\&.W\&., (2002), Astronomy & Astrophysics, 395, 1077-1122\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIdra\fP [arcsec] Projected ffset position in the apparent true-of-date R\&.A\&. direction\&. E\&.g\&. The projected offset between two RA coordinates at a same reference declination, is RA = (RA2 - RA1) * cos(Dec\*<0\*> ) 
.br
\fIddec\fP [arcsec] Projected offset position in the apparent true-of-date declination direction\&. 
.br
\fIpa\fP [deg] Parallactic Angle 
.br
\fIdaz\fP [arcsec] Output offset position in the local azimuth direction\&. It can be a pointer to one of the input coordinates, or NULL if not required\&. 
.br
\fIdel\fP [arcsec] Output offset position in the local elevation direction\&. It can be a pointer to one of the input coordinates, or NULL if not required\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_h2e_offset()\fP 
.PP
\fBnovas_epa()\fP 
.RE
.PP

.PP
References \fBnovas_h2e_offset()\fP\&.
.SS "double novas_epa (double ha, double dec, double lat)"
Returns the equatorial Parallactic Angle (PA) calculated for an R\&.A\&./Dec location of the sky at a given sidereal time\&. The PA is the angle between the local horizontal coordinate directions and the local true-of-date equatorial coordinate directions, at the given location and time\&. The polar wobble is not included in the calculation\&.
.PP
The Parallactic Angle is sometimes referrred to as the Vertical Position Angle (VPA)\&. Both define the same quantity\&.
.PP
\fBParameters\fP
.RS 4
\fIha\fP [h] Hour angle (LST - RA) i\&.e\&., the difference between the Local (apparent) Sidereal Time and the apparent (true-of-date) Right Ascension of observed source\&. 
.br
\fIdec\fP [deg] Apparent (true-of-date) declination of observed source 
.br
\fIlat\fP [deg] Geodetic latitude of observer 
.RE
.PP
\fBReturns\fP
.RS 4
[deg] Parallactic Angle (PA)\&. I\&.e\&., the clockwise position angle of the elevation direction w\&.r\&.t\&. the declination axis in the equatorial system\&. Same as the clockwise position angle of the declination direction w\&.r\&.t\&. the elevation axis, in the horizontal system\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_hpa()\fP 
.PP
novas_lst() 
.PP
\fBnovas_e2h_offset()\fP 
.RE
.PP

.SS "double novas_equ_sep (double ra1, double dec1, double ra2, double dec2)"
Returns the angular separation of two equatorial locations on a sphere\&.
.PP
\fBParameters\fP
.RS 4
\fIra1\fP [h] right ascension of first location 
.br
\fIdec1\fP [deg] declination of first location 
.br
\fIra2\fP [h] right ascension of second location 
.br
\fIdec2\fP [deg] declination of second location 
.RE
.PP
\fBReturns\fP
.RS 4
[deg] the angular separation of the two locations\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_sep()\fP 
.PP
\fBnovas_sun_angle()\fP 
.PP
\fBnovas_moon_angle()\fP 
.RE
.PP

.PP
References \fBnovas_sep()\fP\&.
.SS "int novas_h2e_offset (double daz, double del, double pa, double * dra, double * ddec)"
Converts coordinate offsets, from the local horizontal system to local equatorial offsets\&. Converting between local flat projections and spherical coordinates usually requires a WCS projection\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Calabretta, M\&.R\&., & Greisen, E\&.W\&., (2002), Astronomy & Astrophysics, 395, 1077-1122\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIdaz\fP [arcsec] Projected offset position in the azimuth direction\&. The projected offset between two azimuth positions at the same reference elevation is Az = (Az2 - Az1) * cos(El\*<0\*> )\&. 
.br
\fIdel\fP [arcsec] projected offset position in the elevation direction 
.br
\fIpa\fP [deg] Parallactic Angle 
.br
\fIdra\fP [arcsec] Output offset position in the local true-of-date R\&.A\&. direction\&. It can be a pointer to one of the input coordinates, or NULL if not required\&. 
.br
\fIddec\fP [arcsec] Output offset position in the local true-of-date declination direction\&. It can be a pointer to one of the input coordinates, or NULL if not required\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_e2h_offset()\fP 
.PP
\fBnovas_hpa()\fP 
.RE
.PP

.SS "double novas_helio_dist (double jd_tdb, const \fBobject\fP * source, double * rate)"
Returns a Solar-system body's distance from the Sun, and optionally also the rate of recession\&. It may be useful, e\&.g\&. to calculate the body's heating from the Sun\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tdb\fP [day] Barycentric Dynamical Time (TDB) based Julian date\&. You may want to use a time that is antedated to when the observed light originated from the source\&. 
.br
\fIsource\fP Observed Solar-system source 
.br
\fIrate\fP [AU/day] (optional) Returned rate of recession from Sun 
.RE
.PP
\fBReturns\fP
.RS 4
[AU] Distance from the Sun, or NAN if not a Solar-system source\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_solar_power()\fP 
.PP
\fBnovas_solar_illum()\fP 
.RE
.PP

.PP
References \fBephemeris()\fP, \fBNOVAS_CATALOG_OBJECT\fP, \fBNOVAS_HELIOCENTER\fP, \fBNOVAS_REDUCED_ACCURACY\fP, and \fBobject::type\fP\&.
.SS "double novas_hms_hours (const char * hms)"
Returns the decimal hours for a HMS string specification\&. The hour, minute, and second components may be separated by spaces, tabs, colons \fC:\fP, or a combination thereof\&. Additionally, the hour and minutes may be semarated by the letter \fCh\fP or \fCH\fP, and the minutes and seconds may be separated by \fCm\fP or \fCM\fP, or a single quote `'`\&. For example, all of the lines below specify the same time:
.PP
.PP
.nf

 23:59:59\&.999
 23h 59m 59\&.999
 23h 59' 59\&.999
 23H59'59\&.999
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIhms\fP String specifying hours, minutes, and seconds, which correspond to a time between 0 and 24 h\&. Time in any range is permitted, but the minutes and seconds must be >=0 and <60\&. 
.RE
.PP
\fBReturns\fP
.RS 4
[hours] Corresponding decimal time value, or else NAN if there was an error parsing the string (errno will be set to EINVAL)\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_dms_degrees()\fP 
.RE
.PP

.PP
References \fBnovas_parse_hms()\fP\&.
.SS "double novas_hpa (double az, double el, double lat)"
Returns the horizontal Parallactic Angle (PA) calculated for a gorizontal Az/El location of the sky\&. The PA is the angle between the local horizontal coordinate directions and the local true-of-date equatorial coordinate directions at the given location\&. The polar wobble is not included in the calculation\&.
.PP
The Parallactic Angle is sometimes referrred to as the Vertical Position Angle (VPA)\&. Both define the same quantity\&.
.PP
\fBParameters\fP
.RS 4
\fIaz\fP [deg] Azimuth angle 
.br
\fIel\fP [deg] Elevation angle 
.br
\fIlat\fP [deg] Geodetic latitude of observer 
.RE
.PP
\fBReturns\fP
.RS 4
[deg] Parallactic Angle (PA)\&. I\&.e\&., the clockwise position angle of the declination direction w\&.r\&.t\&. the elevation axis in the horizontal system\&. Same as the the clockwise position angle of the elevation direction w\&.r\&.t\&. the declination axis in the equatorial system\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_epa()\fP 
.PP
\fBnovas_h2e_offset()\fP 
.RE
.PP

.SS "double novas_lsr_to_ssb_vel (double epoch, double ra, double dec, double vLSR)"
Returns a Solar System Baricentric (SSB) radial velocity for a radial velocity that is referenced to the Local Standard of Rest (LSR)\&. Internally, NOVAS always uses barycentric radial velocities, but it is just as common to have catalogs define radial velocities referenced to the LSR\&.
.PP
The SSB motion w\&.r\&.t\&. the barycenter is assumed to be (11\&.1, 12\&.24, 7\&.25) km/s in ICRS (Shoenrich et al\&. 2010)\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Ralph Schoenrich, James Binney, Walter Dehnen, Monthly Notices of the Royal Astronomical Society, Volume 403, Issue 4, April 2010, Pages 1829–1833, https://doi.org/10.1111/j.1365-2966.2010.16253.x 
.PP
.PP
\fBParameters\fP
.RS 4
\fIepoch\fP [yr] Coordinate epoch in which the coordinates and velocities are defined\&. E\&.g\&. 2000\&.0\&. 
.br
\fIra\fP [h] Right-ascenscion of source at given epoch\&. 
.br
\fIdec\fP [deg] Declination of source at given epoch\&. 
.br
\fIvLSR\fP [km/s] radial velocity defined against the Local Standard of Rest (LSR), at given epoch\&.
.RE
.PP
\fBReturns\fP
.RS 4
[km/s] Equivalent Solar-System Barycentric radial velocity\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_cat_entry()\fP 
.PP
\fBnovas_ssb_to_lsr_vel()\fP 
.RE
.PP

.PP
References \fBNOVAS_JD_J2000\fP, \fBprecession()\fP, and \fBradec2vector()\fP\&.
.SS "double novas_parse_dms (const char * dms, char ** tail)"
Parses the decimal degrees for a DMS string specification\&. The degree, (arc)minute, and (arc)second components may be separated by spaces, tabs, colons \fC:\fP, underscore \fC_\fP, or a combination thereof\&. Additionally, the degree and minutes may be semarated by the letter \fCd\fP or \fCD\fP, and the minutes and seconds may be separated by \fCm\fP or \fCM\fP, or a single quote `'`\&. For example, all of the lines below specify the same angle:
.PP
.PP
.nf

 -179:59:59\&.999
 -179 59m 59\&.999
 -179d 59' 59\&.999
 -179D59'59\&.999
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIdms\fP String specifying degrees, minutes, and seconds, which correspond to an angle\&. Angles in any range are permitted, but the minutes and seconds must be >=0 and <60\&. 
.br
\fItail\fP (optional) If not NULL it will be set to the next character in the string after the parsed time\&. 
.RE
.PP
\fBReturns\fP
.RS 4
[deg] Corresponding decimal angle value, or else NAN if there was an error parsing the string (errno will be set to EINVAL)\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_dms_degrees()\fP 
.PP
\fBnovas_parse_hms()\fP 
.RE
.PP

.SS "double novas_parse_hms (const char * hms, char ** tail)"
Parses the decimal hours for a HMS string specification\&. The hour, minute, and second components may be separated by spaces, tabs, colons \fC:\fP, underscore \fC_\fP, or a combination thereof\&. Additionally, the hour and minutes may be semarated by the letter \fCh\fP or \fCH\fP, and the minutes and seconds may be separated by \fCm\fP or \fCM\fP, or a single quote `'`\&. For example, all of the lines below specify the same time:
.PP
.PP
.nf

 23:59:59\&.999
 23h 59m 59\&.999
 23h 59' 59\&.999
 23H59'59\&.999
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIhms\fP String specifying hours, minutes, and seconds, which correspond to a time between 0 and 24 h\&. Time in any range is permitted, but the minutes and seconds must be >=0 and <60\&. 
.br
\fItail\fP (optional) If not NULL it will be set to the next character in the string after the parsed time\&. 
.RE
.PP
\fBReturns\fP
.RS 4
[hours] Corresponding decimal time value, or else NAN if there was an error parsing the string (errno will be set to EINVAL)\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_hms_hours()\fP 
.PP
\fBnovas_parse_dms()\fP 
.RE
.PP

.SS "enum \fBnovas_planet\fP novas_planet_for_name (const char * name)"
Returns the NOVAS planet ID for a given name (case insensitive), or -1 if no match is found\&.
.PP
\fBParameters\fP
.RS 4
\fIname\fP The planet name, or that for the 'Sun', 'Moon' or 'SSB' (case insensitive)\&. The spelled out 'Solar System Barycenter' is also recognized with either spaces, hyphens ('-') or underscores ('_') separating the case insensitive words\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The NOVAS major planet ID, or -1 (errno set to EINVAL) if the input name is NULL or if there is no match for the name provided\&.
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP
\fBSince\fP
.RS 4
1\&.2
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_planet()\fP 
.RE
.PP

.PP
References \fBNOVAS_PLANET_NAMES_INIT\fP, \fBNOVAS_PLANETS\fP, and \fBNOVAS_SSB\fP\&.
.SS "double novas_sep (double lon1, double lat1, double lon2, double lat2)"
Returns the angular separation of two locations on a sphere\&.
.PP
\fBParameters\fP
.RS 4
\fIlon1\fP [deg] longitude of first location 
.br
\fIlat1\fP [deg] latitude of first location 
.br
\fIlon2\fP [deg] longitude of second location 
.br
\fIlat2\fP [deg] latitude of second location 
.RE
.PP
\fBReturns\fP
.RS 4
[deg] the angular separation of the two locations\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_equ_sep()\fP 
.PP
\fBnovas_sun_angle()\fP 
.PP
\fBnovas_moon_angle()\fP 
.RE
.PP

.SS "int novas_set_orbsys_pole (enum \fBnovas_reference_system\fP type, double ra, double dec, \fBnovas_orbital_system\fP * sys)"
Sets the orientation of an orbital system using the RA and DEC coordinates of the pole of the Laplace (or else equatorial) plane relative to which the orbital elements are defined\&. Orbital parameters of planetary satellites normally include the R\&.A\&. and declination of the pole of the local Laplace plane in which the Keplerian orbital elements are referenced\&.
.PP
The system will become referenced to the equatorial plane, the relative obliquity is set to (90 - \fCdec\fP), while the argument of the ascending node ('Omega') is set to (90 + \fCra\fP)\&.
.PP
NOTES: 
.PD 0
.IP "1." 4
You should not expect much precision from the long-range orbital approximations for planetary satellites\&. For applications that require precision at any level, you should rely on appropriate ephemerides, or else on up-to-date short-term orbital elements\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fItype\fP Coordinate reference system in which \fCra\fP and \fCdec\fP are defined (e\&.g\&. NOVAS_GCRS)\&. 
.br
\fIra\fP [h] the R\&.A\&. of the pole of the oribtal reference plane\&. 
.br
\fIdec\fP [deg] the declination of the pole of the oribtal reference plane\&. 
.br
\fIsys\fP Orbital system 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else -1 (errno will be set to EINVAL) if the output \fCsys\fP pointer is NULL\&.
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP
\fBSince\fP
.RS 4
1\&.2
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_orbital_object()\fP 
.RE
.PP

.PP
References \fBNOVAS_EQUATORIAL_PLANE\fP, \fBnovas_orbital_system::obl\fP, \fBnovas_orbital_system::Omega\fP, \fBnovas_orbital_system::plane\fP, and \fBnovas_orbital_system::type\fP\&.
.SS "double novas_solar_power (double jd_tdb, const \fBobject\fP * source)"
Returns the typical incident Solar power on a Solar-system body at the time of observation\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tdb\fP [day] Barycentric Dynamical Time (TDB) based Julian date\&. You may want to use a time that is antedated to when the observed light originated ( was reflected) from the source\&. 
.br
\fIsource\fP Observed Solar-system source 
.RE
.PP
\fBReturns\fP
.RS 4
[W/m\*{2\*} ] Incident Solar power on the illuminated side of the object, or NAN if not a Solar-system source or if the source is the Sun itself\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_solar_illum()\fP 
.RE
.PP

.PP
References \fBnovas_helio_dist()\fP, and \fBNOVAS_SOLAR_CONSTANT\fP\&.
.SS "double novas_ssb_to_lsr_vel (double epoch, double ra, double dec, double vLSR)"
Returns a radial-velocity referenced to the Local Standard of Rest (LSR) for a given Solar-System Barycentric (SSB) radial velocity\&. Internally, NOVAS always uses barycentric radial velocities, but it is just as common to have catalogs define radial velocities referenced to the LSR\&.
.PP
The SSB motion w\&.r\&.t\&. the barycenter is assumed to be (11\&.1, 12\&.24, 7\&.25) km/s in ICRS (Shoenrich et al\&. 2010)\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Ralph Schoenrich, James Binney, Walter Dehnen, Monthly Notices of the Royal Astronomical Society, Volume 403, Issue 4, April 2010, Pages 1829–1833, https://doi.org/10.1111/j.1365-2966.2010.16253.x 
.PP
.PP
\fBParameters\fP
.RS 4
\fIepoch\fP [yr] Coordinate epoch in which the coordinates and velocities are defined\&. E\&.g\&. 2000\&.0\&. 
.br
\fIra\fP [h] Right-ascenscion of source at given epoch\&. 
.br
\fIdec\fP [deg] Declination of source at given epoch\&. 
.br
\fIvLSR\fP [km/s] radial velocity defined against the Local Standard of Rest (LSR), at given epoch\&.
.RE
.PP
\fBReturns\fP
.RS 4
[km/s] Equivalent Solar-System Barycentric radial velocity\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
\fBSee also\fP
.RS 4
\fBmake_cat_entry()\fP 
.PP
\fBnovas_lsr_to_ssb_vel()\fP 
.RE
.PP

.PP
References \fBNOVAS_JD_J2000\fP, \fBprecession()\fP, and \fBradec2vector()\fP\&.
.SS "double novas_v2z (double vel)"
Converts a radial recession velocity to a redshift value (z = f / f\*<rest\*> )\&. It is based on the relativistic formula: 
.PP
.nf

 1 + z = sqrt((1 + ) / (1 - ))
.fi
.PP
 where  = v / c\&.
.PP
\fBParameters\fP
.RS 4
\fIvel\fP [km/s] velocity (i\&.e\&. rate) of recession\&. 
.RE
.PP
\fBReturns\fP
.RS 4
the corresponding redshift value ( / \*<rest\*> ), or NAN if the input velocity is invalid (i\&.e\&., it exceeds the speed of light)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_z2v()\fP 
.PP
\fBnovas_z_add()\fP
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP

.PP
References \fBC\fP, and \fBNOVAS_KMS\fP\&.
.SS "int novas_xyz_to_uvw (const double * xyz, double ha, double dec, double * uvw)"
Converts rectangular telescope x,y,z (absolute or relative) coordinates (in ITRS) to equatorial u,v,w projected coordinates for a specified line of sight\&.
.PP
x,y,z are Cartesian coordinates w\&.r\&.t the Greenwich meridian\&. The directions are x: long=0, lat=0; y: long=90, lat=0; z: lat=90\&.
.PP
u,v,w are Cartesian coordinates (u,v) along the local equatorial R\&.A\&. and declination directions as seen from a direction on the sky (w)\&.
.PP
\fBParameters\fP
.RS 4
\fIxyz\fP [arb\&.u\&.] Absolute or relative x,y,z coordinates (double[3])\&. 
.br
\fIha\fP [h] Hourangle (LST - RA) i\&.e\&., the difference between the Local (apparent) Sidereal Time and the apparent (true-of-date) Right Ascension of observed source\&. 
.br
\fIdec\fP [deg] Apparent (true-of-date) declination of source 
.br
\fIuvw\fP [arb\&.u\&.] Converted u,v,w coordinates (double[3]) in same units as xyz\&. It may be the same vector as the input\&.
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or else -1 if either vector argument is NULL (errno will be set to EINVAL)
.RE
.PP
\fBSince\fP
.RS 4
1\&.3 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBnovas_xyz_to_los()\fP\&.
.SS "double novas_z_add (double z1, double z2)"
Compounds two redshift corrections, e\&.g\&. to apply (or undo) a series gravitational redshift corrections and/or corrections for a moving observer\&. It's effectively using (1 + z) = (1 + z1) * (1 + z2)\&.
.PP
\fBParameters\fP
.RS 4
\fIz1\fP One of the redshift values 
.br
\fIz2\fP The other redshift value 
.RE
.PP
\fBReturns\fP
.RS 4
The compound redshift value, ot NAN if either input redshift is invalid (errno will be set to EINVAL)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBgrav_redshift()\fP 
.PP
\fBredshift_vrad()\fP 
.PP
\fBunredshift_vrad()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.SS "double novas_z_inv (double z)"
Returns the inverse of a redshift value, that is the redshift for a body moving with the same velocity as the original but in the opposite direction\&.
.PP
\fBParameters\fP
.RS 4
\fIz\fP A redhift value 
.RE
.PP
\fBReturns\fP
.RS 4
The redshift value for a body moving in the opposite direction with the same speed, or NAN if the input redshift is invalid\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBnovas_z_add()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.SS "int place_cirs (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the Celestial Intermediate Reference System (CIRS) dynamical position position of a source as 'seen' from the geocenter at the given time of observation\&. See \fC\fBplace()\fP\fP for more information\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated CIRS position data 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_tod()\fP 
.PP
\fBplace_gcrs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_CIRS\fP, and \fBplace()\fP\&.
.SS "int place_gcrs (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the Geocentric Celestial Reference System (GCRS) position of a source (as 'seen' from the geocenter) at the given time of observation\&. Unlike \fC\fBplace_icrs()\fP\fP, this includes aberration for the moving frame of the geocenter as well as gravitational deflections calculated for a virtual observer located at the geocenter\&. See \fC\fBplace()\fP\fP for more information\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated GCRS position data 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_icrs()\fP 
.PP
\fBplace_cirs()\fP 
.PP
\fBplace_tod()\fP 
.PP
\fBvirtual_star()\fP 
.PP
\fBvirtual_planet()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_GCRS\fP, and \fBplace()\fP\&.
.SS "int place_icrs (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the International Celestial Reference System (ICRS) position of a source\&. (from the geocenter)\&. Unlike \fC\fBplace_gcrs()\fP\fP, this version does not include aberration or gravitational deflection corrections\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated geocentric ICRS position data (Unlike \fBplace_gcrs()\fP, the calculated coordinates do not account for aberration or gravitational deflection)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_gcrs()\fP 
.PP
\fBplace_cirs()\fP 
.PP
\fBplace_tod()\fP 
.PP
\fBmean_star()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_ICRS\fP, and \fBplace()\fP\&.
.SS "int place_j2000 (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the J2000 dynamical position position of a source as 'seen' from the geocenter at the given time of observation\&. See \fC\fBplace()\fP\fP for more information\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated CIRS position data 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_cirs()\fP 
.PP
\fBplace_gcrs()\fP 
.PP
\fBapp_star()\fP 
.PP
\fBapp_planet()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_J2000\fP, and \fBplace()\fP\&.
.SS "int place_mod (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the Mean of Date (MOD) dynamical position position of a source as 'seen' from the geocenter at the given time of observation\&. See \fC\fBplace()\fP\fP for more information\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated CIRS position data 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_cirs()\fP 
.PP
\fBplace_gcrs()\fP 
.PP
\fBapp_star()\fP 
.PP
\fBapp_planet()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_MOD\fP, and \fBplace()\fP\&.
.SS "int place_tod (double jd_tt, const \fBobject\fP * source, enum \fBnovas_accuracy\fP accuracy, \fBsky_pos\fP * pos)"
Computes the True of Date (TOD) dynamical position position of a source as 'seen' from the geocenter at the given time of observation\&. See \fC\fBplace()\fP\fP for more information\&.
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date of observation\&. 
.br
\fIsource\fP Catalog source or solar_system body\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIpos\fP Structure to populate with the calculated CIRS position data 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if any of the input pointer arguments is NULL, or else an error from \fBplace()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBplace_cirs()\fP 
.PP
\fBplace_gcrs()\fP 
.PP
\fBapp_star()\fP 
.PP
\fBapp_planet()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBNOVAS_TOD\fP, and \fBplace()\fP\&.
.SS "double redshift_vrad (double vrad, double z)"
Applies an incremental redshift correction to a radial velocity\&. For example, you may use this function to correct a radial velocity calculated by \fC\fBrad_vel()\fP\fP or \fC\fBrad_vel2()\fP\fP for a Solar-system body to account for the gravitational redshift for light originating at a specific distance away from the body\&. For the Sun, you may want to undo the redshift correction applied for the photosphere using \fC\fBunredshift_vrad()\fP\fP first\&.
.PP
\fBParameters\fP
.RS 4
\fIvrad\fP [km/s] Radial velocity 
.br
\fIz\fP Redshift correction to apply 
.RE
.PP
\fBReturns\fP
.RS 4
[km/s] The redshift corrected radial velocity or NAN if the redshift value is invalid (errno will be set to EINVAL)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBunredshift_vrad()\fP 
.PP
\fBgrav_redshift()\fP 
.PP
\fBnovas_z_add()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBnovas_v2z()\fP, and \fBnovas_z2v()\fP\&.
.SS "int tod_to_cirs (double jd_tt, enum \fBnovas_accuracy\fP accuracy, const double * in, double * out)"
Transforms a rectangular equatorial (x, y, z) vector from the True of Date (TOD) reference system to the Celestial Intermediate Reference System (CIRS) at the given epoch to the \&.
.PP
NOTES: 
.PD 0
.IP "1." 4
The accuracy of the output CIRS coordinates depends on how the input TOD coordinates were obtained\&. If TOD was calculated via the old (pre IAU 2006) method, using the Lieske et al\&. 1997 nutation model, then the limited accuracy of that model will affect the resulting coordinates\&. This is the case for the SuperNOVAS functions \fBnovas_geom_posvel()\fP and \fBnovas_sky_pos()\fP also, when called with \fCNOVAS_TOD\fP as the system, as well as all legacy NOVAS C functions that produce TOD coordinates\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tt\fP [day] Terrestrial Time (TT) based Julian date that defines the output epoch\&. Typically it does not require much precision, and Julian dates in other time measures will be unlikely to affect the result 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIin\fP CIRS Input (x, y, z) position or velocity vector 
.br
\fIout\fP Output position or velocity 3-vector in the True of Date (TOD) frame\&. It can be the same vector as the input\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, or -1 if either of the vector arguments is NULL or the accuracy is invalid, or 10 + the error from \fBcio_location()\fP, or else 20 + the error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBcirs_to_tod()\fP 
.PP
\fBapp_to_cirs_ra()\fP 
.PP
\fBtod_to_gcrs()\fP 
.PP
\fBtod_to_j2000()\fP 
.PP
\fBtod_to_itrs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.1 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcio_ra()\fP, and \fBspin()\fP\&.
.SS "int tod_to_itrs (double jd_tt_high, double jd_tt_low, double ut1_to_tt, enum \fBnovas_accuracy\fP accuracy, double xp, double yp, const double * in, double * out)"
Rotates a position vector from the dynamical True of Date (TOD) frame of date the Earth-fixed ITRS frame (pre IAU 2000 method)\&.
.PP
If both 'xp' and 'yp' are set to 0 no polar motion is included in the transformation\&.
.PP
If extreme (sub-microarcsecond) accuracy is not required, you can use UT1-based Julian date instead of the TT-based Julian date and set the 'ut1_to_tt' argument to 0\&.0\&. and you can use UTC-based Julian date the same way\&.for arcsec-level precision also\&.
.PP
REFERENCES: 
.PD 0
.IP "1." 4
Kaplan, G\&. H\&. et\&. al\&. (1989)\&. Astron\&. Journ\&. 97, 1197-1210\&. 
.IP "2." 4
Kaplan, G\&. H\&. (2003), 'Another Look at Non-Rotating Origins', Proceedings of IAU XXV Joint Discussion 16\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIjd_tt_high\fP [day] High-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIjd_tt_low\fP [day] Low-order part of Terrestrial Time (TT) based Julian date\&. 
.br
\fIut1_to_tt\fP [s] TT - UT1 Time difference in seconds\&. 
.br
\fIaccuracy\fP NOVAS_FULL_ACCURACY (0) or NOVAS_REDUCED_ACCURACY (1) 
.br
\fIxp\fP [arcsec] Conventionally-defined X coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIyp\fP [arcsec] Conventionally-defined Y coordinate of celestial intermediate pole with respect to ITRS pole, in arcseconds\&. 
.br
\fIin\fP Position vector, geocentric equatorial rectangular coordinates, referred to True of Date (TOD) axes (celestial system)\&. 
.br
\fIout\fP Position vector, geocentric equatorial rectangular coordinates, referred to ITRS axes (terrestrial system)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
0 if successful, -1 if either of the vector arguments is NULL, 1 if 'accuracy' is invalid, 2 if 'method' is invalid 10--20, 3 if the method and option are mutually incompatible, or else 10 + the error from \fBcio_location()\fP, or 20 + error from \fBcio_basis()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBcirs_to_itrs()\fP 
.PP
\fBitrs_to_tod()\fP 
.PP
\fBj2000_to_tod()\fP 
.PP
\fBtod_to_gcrs()\fP 
.PP
\fBtod_to_j2000()\fP 
.PP
\fBtod_to_cirs()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBcel2ter()\fP, \fBEROT_GST\fP, and \fBNOVAS_DYNAMICAL_CLASS\fP\&.
.SS "double unredshift_vrad (double vrad, double z)"
Undoes an incremental redshift correction that was applied to radial velocity\&.
.PP
\fBParameters\fP
.RS 4
\fIvrad\fP [km/s] Radial velocity 
.br
\fIz\fP Redshift correction to apply 
.RE
.PP
\fBReturns\fP
.RS 4
[km/s] The radial velocity without the redshift correction or NAN if the redshift value is invalid\&. (errno will be set to EINVAL)
.RE
.PP
\fBSee also\fP
.RS 4
\fBredshift_vrad()\fP 
.PP
\fBgrav_redshift()\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.2 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP

.PP
References \fBnovas_v2z()\fP, and \fBnovas_z2v()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for SuperNOVAS from the source code\&.
